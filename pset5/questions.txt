0.  Pneumonoultramicroscopicsilicovolcanoconiosis is an artificial long word said to mean a lung disease caused by inhaling very fine ash and sand dust. It is the longest word in the English dictionary and the longest word that our speller program will utilize.
1.  getrusage stands for Get Resource Usage. It returns the resource usage measures for either the calling process, all the children of the calling process, or for the calling thread.
2.  The struct rusage has 16 members. Not all the fields are completed, and the unmaintained fields are set to zero.
3.  Before and after are passed in by reference because it takes up less memory and leads to more efficiency. If they are passed in by value, it would take up more memory because the values would be copied over. getrusage also requires a pointer for the second argument.
4.  Preparing to report misspellings -
    1. A index, misspellings, and words integer are initialized to 0.
    2. A char array is initialized to be the length of 46.
    3. A FOR loop is created in which c is the character read from the fp file returning an unsigned char cast to an int. The for loop will run while c is not equal to the end of the file.
    4. Inside the FOR loop is 3 prong conditional statement:
    5. The first condition evaluates if the character is an aplhabetical character or an apostrophe. If so, the character is added to the word array at the index of 0. Then the index is incremented so that the next character will be placed after the first. The second IF condition within it checks if the index is greater than the max length of 46. If it is, the WHILE loop consumes the rest of the word so we can start on the next word since the word is to long to be in the dictionary.
    6. The second condition in the FOR loop checks to see if the character is a digit. If the character is a digit, a WHILE loop consumes the rest of the word since the spell checker ignores words with numbers.
    7. The final conditional statement in the FOR loop evaluates if the index is greater than 0. It basically means that we have letters in our word array and have produced a full word. The word is terminated by adding a zero to the end of the array and incrementing words. getrusage takes account for the before and after times of the check function. Misspelled is true is the word is not found in the dictionary. If it is misspelled, the word is printed and misspellings is incremented.
    8. At the end of the loop, index is set to zero so a new word can be processed. Once all the words are processed, and the EOF is reached, the loop will stop and the program will continue running.
5.  fgetc reads characters one by one until it hits a new line or the EOF. It will not skip any whitespace. fscanf, on the other hand, skips all the leading whitespace and reads until the next whitespace or EOF. fscanf would cause problems within our spelling program becasue words aren't always seperated by spaces. If there are no spaces to seperate each word, the characters would just get stored into one big array until it becomes larger than the max length and the word would be ignored.
6.  The parameters for the check and load functions are set as constants pointers because the beginnings of both pieces of memory that hold both the word and dictionary should never be forgotten. Forgetting these beginning pointers can cause a lot of problems and as Professor Malan says in lecture, copy these pointers to another variable if they need to be modified leaving the original pointers alone.
7.  I used a trie data structure to implement my spell checker. Within each trie structure node, I have a bool variable (is_word) that is set to true if that node is the last node in the word tree to make it a complete word. I also have an array of 27 node structure pointers. Each value in the array corresponds to a different letter of the alphabet plus the addition of an apostrophe. In this way, these trie structures can be linked together, letter after letter, to form full length words.
8.  When I first got my code fully functioning with all 4 functions, the program was very slow. It would take around 5 seconds for it to finish spell checking using the large dictionary.
9.  I didn't make any changes to my code to improve its performance. I realized that as I was writing and debugging my unload function, so much memory was being taken up within the IDE without any being freed. When I finally got the unload function to work with all of the memory freed, validated by valgrind, the program was still running show because of all of my previous work. The next day, I ran my program again and it finished within .20 seconds. I just needed to relaunch the IDE to free up memory so that my program would run normally again.
10. I felt like the recursive method in my unload function took a while to understand. I spent so much time thinking through the recursive process and at the end it turned out to be a couple of lines of code. Although it did take long, I felt like the recursive call helped improve the performance of my spell checker.
